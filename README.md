# ding

## これは何ですか?

`ping`コマンドを真似したもの。\
ただし都合上, macOS と inetutils のパッチワークになっている。

## `ping`コマンドって何をするもの？

IP(インターネットプロトコル)で通信するネットワーク, いわゆる IP ネットワークにおいて, 疎通確認に使われるコマンド。\
ある宛先アドレスについて, 自分のマシンが接続されている IP ネットワークに自分 → 宛先の経路があること, さらに逆向き, つまり宛先 → 自分の経路があることをテストする。

## どうやってテストする?

"[ICMP](https://ja.wikipedia.org/wiki/Internet_Control_Message_Protocol) Echo"というパケットを受けとったホストは, その内容をそのまま"ICMP Echo Reply"パケットに載せて送信元に送り返すべし,\
ということが[ICMP で規定されている](https://datatracker.ietf.org/doc/html/rfc792):

> The data received in the echo message must be returned in the echo reply message.

このことを利用すると,

1. まず ICMP Echo パケットを送信した上で
2. それに対する応答の ICMP Echo Reply パケットを観測する

ことで, 自分と宛先との間にネットワーク経路があることが確認できる。

※ICMP Echo に対して ICMP Echo Reply を送り返す動作は TCP や UDP よりも下, IP と同じレイヤーで起きる(ICMP 自体は TCP, UDP と同じレイヤーなのだが・・・ややこしい)。\
それゆえ, ICMP ひいては`ping`コマンドには「ポート」という概念がない。

## どうやって ICMP Echo を送る?

ネットワークソケットを使う。

```c
	int sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
```

`socket`関数の引数について:

- `AF_INET` アドレスファミリーが IPv4 であること示す。
- `SOCK_RAW` **ソケットが Raw である**ことを示す。
- `IPPROTO_ICMP` プロトコルとして ICMP を使うことを示す。

最も重要なのが`SOCK_RAW`で, これは生成されるソケットが Raw ソケットになることを示す。

Raw だと何が違うのか・・・を一言で説明するのは筆者のスキルレベルでは難しい。\
Raw でない場合に覆い隠されていたパケット(データグラム)という概念に直接触れることになるのが Raw, といった感じだろうか。\
Raw ソケットを使うと, **パケット(データグラム)を直接送受信する**ことが可能になる。

## どうやって ICMP Echo Reply を受信する?

送信に使ったのと同じソケットで受信する。

・・・のだが、送信との兼ね合いを考える必要がある。\
というのは, `ping`は一定間隔で Echo を送信し続けるため。\
「Echo を 1 つ送信した後, Echo Reply を受信するまで待つ」という実装ではこれが実現できない。

ソケットをノンブロッキングにして`select`などのイベント監視手段で監視するのが, おそらく最もシンプルな解だと思われる。\
しかし課題の都合上`select`の類が使用禁止なのでこの手は使えない。

そのため今回は、「受信(`recvmsg`呼び出し)のたびにソケットに受信タイムアウトを設定する」というアプローチを選択した。
